import 'dart:convert';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:http/http.dart';

import 'exceptions.dart';
import 'failed_response.dart';
import 'failures.dart';

mixin ErrorHandler {
  /// Map the http status to the respective exception class and throw it
  ///
  /// Exception to throws:
  ///// Generated by https://quicktype.io

  /// [ApiLogicException] Throws if HTTP status belongs to 400, 401, 403.
  ///
  /// [ServerErrorException] Throw is HTTP status belongs to 5xx.;
  ///
  /// [UnhandledServerErrorException] Throw for non success status that is not listed above
  Future<CustomException> getNonSuccessHttpResponseException(
    Response response,
  ) async {
    Map<String, dynamic> json = {};
    try {
      json = jsonDecode(response.body);
    } catch (_) {
      json = {'message': response.body};
    }
    final failedResponse = FailedResponse.fromMap(json);
    CustomException exceptionToThrow = UnhandledServerErrorException(
      statusCode: failedResponse.status,
      body: failedResponse.message,
    );
    if (failedResponse.status == 401) {
      throw ForbiddenException(
        body: failedResponse.message,
        statusCode: failedResponse.status,
      );
    } else if (failedResponse.status >= 400 && failedResponse.status <= 499) {
      exceptionToThrow = ApiLogicException(
        errorCode: failedResponse.status,
        title: failedResponse.message,
        message: failedResponse.message,
      );
    } else if (failedResponse.status >= 500) {
      exceptionToThrow = ServerErrorException(statusCode: failedResponse.status, body: failedResponse.message);
    }

    return exceptionToThrow;
  }

  /// Supported exception map to failure
  ///
  /// - FormatException => JsonFormatFailure
  /// - ConnectionUnavailableException => ConnectionUnavailableFailure
  /// - ServerErrorException => ServerFailure
  /// - UnhandledServerErrorException => UnhandledServerFailure
  /// - ApiLogicException => UnhandledLogicException. **NOTE** Passing this means logic error is not being handle at business logic side
  Failure mapCommonExceptionToFailure(Exception exception) {
    if (exception is FormatException) {
      debugPrint("FormatException ${exception.message}");
      return JsonFormatFailure(message: "format_failure");
    }

    if (exception is ConnectionUnavailableException) {
      debugPrint("ConnectionUnavailableException");
      return ConnectionUnavailableFailure();
    }

    if (exception is ApiLogicException) {
      debugPrint("ApiLogicException ${exception.message}");
      return LogicFailure(message: exception.message, title: exception.title);
    }
    if (exception is ServerErrorException) {
      debugPrint("ServerErrorException ${exception.statusCode}");
      return ServerFailure(statusCode: exception.statusCode, message: exception.body);
    }

    if (exception is UnhandledServerErrorException) {
      debugPrint("UnhandledServerErrorException ${exception.statusCode}");
      return UnhandledServerFailure(statusCode: exception.statusCode, message: exception.body);
    }

    if (exception is ForbiddenException) {
      debugPrint("ForbiddenException ${exception.statusCode}");
      return ForbiddenFailure(statusCode: exception.statusCode, message: exception.body);
    }
    if (exception is SocketException) {
      debugPrint("SocketException");
      return ConnectionUnavailableFailure();
    }

    debugPrint("UnhandledFailure ${exception.toString()}");
    return UnhandledFailure(className: exception.runtimeType.toString(), message: "An error occurred, Try again");
  }
}
